\section{Проектирование}

Проектирование планировщика ресурсов предполагает собой разработку, состоящую из следующих этапов:
\begin{itemize}
	\item анализ доступных средств платформы .Net;
	\item выбор типа базы данных и её провайдера;
	\item определение алгоритмов, по которым будет работать программный модуль;
	\item написание и отладка программного модуля.
\end{itemize}


\subsection{Проектирование архитектуры прототипа системы решения, включая разработку структуры (компоненты и связи между ними), внутреннего и внешнего функционирования.}

\subsubsection{Анализ доступных средств платформы .Net}

На данный момент платформу .Net можно условно поделить на две части - .Net Framework и .Net Core.

На данный момент платформа .Net Framework является поддерживаемой, но устаревшей, и по рекомендациям Microsoft \cite{microrec} не следует начинать новые проекты на этой платформе. Дополнительно необходимо указать, что платформа .Net Framework не является кроссплатформенной и работает только в операционных системах семейства Windows, что существенно ограничивает возможности современной разработки на ее основе на данный момент.

Открытый кроссплатформенный фреймворк .Net Core является преемником .Net Framework. Именно Core версию Microsoft рекомендует для всех новых проектов. Главным отличием новой платформы в первую очередь стала поддержка работы в Unix-системах (Linux, MacOS), соответственно все сервисы, написанные на .Net Core, без каких-либо ограничений могут быть использованы в современной серверной парадигме: Linux серверы, Docker, контейнеризация и виртуализация.

Для данного проекта была выбрана самая акутальная версия фреймворка .Net Core - .NET 6, так как она является LTS-версией, а так же соответствует всем требованиям проекта - открытости и кроссплатформенности.

В качестве платформы для взаимодействия с пользователем был выбран серверный вариант фреймворка Blazor. Blazor - это бесплатный и открытый фреймворк для написания веб приложений на языке C\#, поддерживающий реактивность, то есть работающий напрямую с DOM-элементами, а не HTML страницами. Blazor делится на Blazor WebAssembly - полностью клиентское приложение и на Blazor Server - клиент-серверную реализацию, в которой пользовательская и серверная часть общаются между собой по протоколу SignalR. SignalR - это бесплатная библиотека с открытым исходным кодом для Microsoft ASP.NET, которая позволяет серверному коду отправлять асинхронные уведомления веб-приложениям на стороне клиента. Библиотека включает в себя серверные и клиентские компоненты JavaScript.



\subsubsection{Определение алгоритмов, по которым будет работать программный модуль}

За планирование и/или перепланирование в планировщике будет отвечать библиотека Google OR-Tools. Задача, изложенная выше в первой главе, однозначно подходит под определение задач целочисленного программирования в ограничениях, так как каждый объект виртуальной модели в данной задаче можно определить как целочисленную переменную или их множество, на которые в явном виде можно наложить ряд ограничений и целевых функций, соответствующих условиям задачи.

Для такого типа задач пакет Google OR-Tools предоставляет отдельный класс для решения задач целочисленного программирования в ограничениях - CP-SAT, где CP (от англ. Constraint Programming - Программирование в ограничениях) - непосредственно целочисленное программирование в ограничениях, а SAT (от англ. Satisfiability - Удовлетворимость) - указывает, что целью решения данного класса задач является не нахождение одного конкретного результата, а нахождение одного или нескольких решений, удовлетворяющих ограничениям, наложенным на входные данные.
 
\subsubsection{Выбор типа базы данных и её провайдера.}

В первую очередь при выборе типа баз данных встаёт вопрос об использовании реляционных или нереляционных баз данных. В целом в EAM-системах обычно используются именно реляционные базы данных, так как этому способствует необходимость в четкой иерархической структуре модели представления активов предприятия. Также в EAM-системах редко встречается необходимость в шардинге - то есть в горизонтальном расширении данных для обеспечения масштабируемости. Исходя из этого для данного проекта была выбрана именно реляционная база данных.

В качестве реляционной СУБД был выбран PostgreSQL. PostgreSQL - это бесплатная система управления реляционными базами данных с открытым исходным кодом, в которой особое внимание уделяется расширяемости и соответствию стандарту SQL.

В данный момент ввиду острой необходимости в импортозамещении и независимости от зарубежных ПО, сервисов и средств именно СУБД PostgreSQL видится лучшим вариантом. У российских разработчиков уже есть большой опыт в развитии своих доработок и ответвлений PostgreSQL. Так, например, давно и успешно применяется ответвление Postgres Pro \cite{postgrespro}, СУБД ЛИНТЕР-ВС на базе PostgreSQL используется в ОС МСВС, а в дистрибутив операционной системы Astra Linux Special Edition (версия для автоматизированных систем в защищённом исполнении, обрабатывающих информацию со степенью секретности «совершенно секретно» включительно) включена СУБД PostgreSQL, доработанная по требованиям безопасности информации. Особенно важно, что СУБД Postgres PRO входит в реестр российского ПО \cite{reestrpp}.

\subsubsection{Проектирование архитектуры}

Желаемая архитектура системы представлена на рисунке \ref{arch}. Предполагается, что разрабатываемая система ресурсного планирования будет являться отдельным сервером планирования, работающим независимо от ЕАМ-системы. Связь между ЕАМ-системой и сервером планирования должна осуществляться посредством наличия общей базы данных и API для передачи команд и промежуточных объектов.

\addimghere{arch}{1}{Архитектура системы.}{arch}

Архитектуру самого сервера планирования (рис. \ref{archsp}) можно представить как API, который посредством контроллера вызывает сервис перепланирования, использующий библиотеку OR-Tools.

\addimghere{archsp}{0.7}{Архитектура сервера планирования.}{archsp}

Рассмотрим представленную на рисунке \ref{archsp} архитектуру сервера планирования более подробно.

Фронтенд (EAM-система) отправляет команду через API, в котором в привязанном к маршруту контроллере выполняются определенные действия - инициализация перепланирования выбранных через фронтенд работ или их же, но уже перепланированных, отправка обратно во фронтенд (ЕАМ-систему) на отображение и подтверждение.

Фактически самой главной частью представленного сервера планирования является сервис OR-Tools. Именно данный сервис отвечает за основную часть - непосредственно процесс планирования предварительно заданных работ. В данном сервисе происходит инициализация модели, задание ограничений для этой модели, а также задается целевая функция, то есть функция, относительно которой будут искаться все удовлетворяющие ограничениям решения для данной модели.


\subsection{Разработка прототипов алгоритмов, структур данных.}

\subsubsection{Типы данных Google OR-Tools}

Все объекты, для которых проводится процесс оптимизации, должны быть представлены в фреймворке Google OR-Tools одним из следующих типов данных:

\begin{itemize}
	\item IntVar; 
	\item BoolVar;
	\item IntervalVar;
	\item OptionalIntervalVar.
\end{itemize}

Тип данных IntVar это объект, который может принимать любое целочисленное значение в определенных диапазонах, такой диапазон называется доменом. В коде объявляется как
%\begin{lstlisting}
%	var integer_variable = model.NewIntVar(0, 100, "Integer Varible");
%\end{lstlisting}
\mint[breaklines]{csharp}|var integer_variable = model.NewIntVar(0, 100, "Integer Varible");|
где 0 и 100 это домен переменной, а "Integer Variable" - произвольное имя переменной, задаваемое пользователем.

Тип данных BoolVar представляет собой переменную для хранения логических значений. Внутри фреймворка BoolVar аналогичен типу IntVar, но с доменом $[0, 1]$. Выделен в отдельный тип данных для удобства программирования.

Пример объявления:
%\begin{lstlisting}
%	var boolean_variable1 = model.NewBoolVar("Boolean Variable");
%\end{lstlisting}
\mint[breaklines]{csharp}|var boolean_variable1 = model.NewBoolVar("Boolean Variable");|
В качестве параметров при объявлении передается только произвольное имя переменной, так как домен по умолчанию лежит в пределах $[0, 1]$

Тип IntervalVar представляет собой интервальную переменную. Интервальная переменная - это и ограничение, и переменная. Она определяется тремя целочисленными переменными: start, size и end.

Она является ограничением, потому что внутри она обеспечивает выполнение того, что start + size == end.

Это также переменная, поскольку она может задаваться в определенных методах ограничения планирования, таких как: NoOverlap, NoOverlap2D, Cumulative.

Объявляется так:
%\begin{lstlisting}
%	var interval_variable = model.NewIntervalVar(start, size, end, "Interval Variable");
%\end{lstlisting}
\mint[breaklines]{csharp}|var interval_variable = model.NewIntervalVar(start, size, end, "Interval Variable");|
в которой start - предполагаемый момент начала интервала, size - размер (длина) интервала - обычно фиксированное целое число, end - предполагаемый момент окончания интервала. 

В качестве значений start и end могут приниматься либо целые числа - в таком случае, например, суть оптимизации такой переменной заключается в нахождении её места на горизонте планирования, либо переменные типа IntVar - тогда оптимизация данной переменной будет зависеть и от также неизвестных переменных определенного домена.

Последним из доступных типов является OptionalIntervalVar - опциональный интервал. Этот отличается от IntervalVar литералом is\_present, который указывает, активна (то есть фактически присутствует в модели и участвует в процессе оптимизации) данная переменная или нет.

Пример:
%\begin{lstlisting}
%	var optional_interval_variable = model.NewOptionalIntervalVar(start, size, end, is_presernt "Optional Interval Variable");
%\end{lstlisting}

\mint[breaklines]{csharp}|var optional_interval_variable = model.NewOptionalIntervalVar(start, size, end, is_present "Optional Interval Variable");|
в которой is\_present представляет собой логическая переменную типа BoolVar.

Представленные выше типы данных определяются как часть модели. Модель это некоторое условное пространство имён, которое содержит в себе переменные-объекты модели, методы для работы с объектами, ограничения для них, а также методы для задания целевой функции модели.

Решение модели эквивалентно нахождению для каждой переменной единственного значения из множества начальных значений (называемого начальной областью), такого, что модель выполнима, или оптимальна, если вы предоставили целевую функцию.

Основными ограничениями для модели можно выделить:
\begin{itemize}
	\item Add; 
	\item AddNoOverlap;
	\item AddAllDifferent;
	\item AddImplication.
\end{itemize}

Метод Add добавляет ограничение в виде линейного выражения вида $x + y = z$, где $x, y, z$ - целые числа или переменные типа IntVar.

Ограничение AddNoOverlap гарантирует, что все выбранные для него интервалы не пересекаются во времени.

AddAllDifferent заставляет все переменные иметь разные значения.

Метод AddImplication обеспечивает ограничение вида ЕСЛИ, ТО - $a => b$.

Класс LinearExpr позволяет производить над типами данных OR-Tools различные математические операции, такие как сумма, скалярное произведение, умножение на коэффициент - Sum(), ScaleProd(), Term().

Для задания целевой функции фреймворк предлагает два метода - maximize и minimize. Данные методы позволяют максимизировать или минимизировать некоторые необходимые параметры модели.


\subsubsection{Определение требований к модели}

Так как при планировании работ периоды занятости ресурсов могут накладываться друг на друга независимо от качества планирования, то ожидается, что не все работы окажутся запланированными. Соответственно, цель работы планировщика заключается в максимизации количества запланированных работ и выражается формулой:

% Далее идёт расшифровка параметров, входящих в формулу
\begin{minipage}[h]{1\textwidth}
	\begin{equation}
		\max\sum_{0}^{N}(n_{0}, ..., n_{N})
	\end{equation}
	\begin{tabular}{llll}
		где & $N$ & {---} & количество работ; \\
		& $n$ & {---} & \begin{tabular}[t]{@{}l@{}}переменная домена $[0,1]$, означающая присутствие работы.\end{tabular}
	\end{tabular}
\end{minipage}

\bigbreak
Так как работы одного типа и работы, привязанные к одному человеку, никак не должны пересекаться, то должно так же выполняться следующее ограничение:

\begin{minipage}[h]{1\textwidth}
	\begin{equation}
		\forall p \in I \enspace \forall q \in I: p \neq q \implies V_p \cap V_q \neq \emptyset
	\end{equation}
	\begin{tabular}{llll}
		где & $V_i$ & {---} & семейство интервалов; \\
		& $p, q$ & {---} & \begin{tabular}[t]{@{}l@{}}интервал множества $V$.\end{tabular}
	\end{tabular}
\end{minipage}

\bigbreak
Из дополнительных ограничений следует отметить:

Для каждого рабочего количество запланированных работ должно быть меньше или равно изначальному количеству.

Так как в типах работ присутствуют плановые работы, то для работ таких типов должна соблюдаться определенная периодичность, например, планирование раз в день, неделю, месяц и так далее.

\clearpage
