\section{Реализация предлагаемого решения и его оценка}

Реализация системы ресурсного планирования состоит в описании модели методами целочисленного программирования, интеграции этой модели в сервис планирования и написания подобия EAM-фронтенда, который будет взаимодействовать с сервисом, то есть отображать исходные данные, запускать процесс перепланирования, отображать результаты работы сервиса, а также различную статистику.

\subsection{Реализация прототипа технического решения}

\subsubsection{Описание инструментов и форматов данных}

В качестве среды программирования была выбрана Visual Studio 2022 под операционной системой Windows 11.

Библиотека Google Or-Tools поставляется из официального NuGet репозитория.

Как сервис ресурсного планирования, так и частичный функционал подобия ЕАМ-системы будут реализованы с помощью Blazor Server.

Данные о ресурсах и работах будут храниться в реляционной базе данных PostgreSQL, взаимодействие с базой данных извне будет происходить через SQL клиент DBeaver, а внутри проекта через ORM Entity Framework Core.

Структурная схема использованных инструментов представлена на рисунке \ref{instruments}.

\addimghere{instruments}{0.8}{Структура взаимосвязей инструментов.}{instruments}

\subsubsection{Описание прототипа программной реализации}
\subsubsection{Описание модели базы данных}

Схема реляционной базы данных, достаточной для описания модели, представленной в главе 1 представлена на рисунке \ref{schema}

\addimghere{schema}{1}{Схема базы данных.}{schema}

В схеме представлены следующие сущности:
\begin{itemize}
	\item jobs
	\item jobtypes
	\item workers
	\item jobsworkers
\end{itemize}

Сущность jobs представляет все работы, запланированные на текущий момент времени.

Сущность jobtypes представляет все доступные типы работ. Связана с сущностью jobs связью один ко многим.

В таблице workers находятся все рабочие, которые могут быть привязаны к работам. Связана с таблицей jobs связью многие ко многим, поэтому необходимо использование промежуточной таблицы jobsworkers.

\subsubsection{Прототипирование ЕАМ-системы}

\subsubsection{Моделирование системы средствами программирования в ограничениях}

Все действия по планированию и/или перепланированию работ происходят на горизонте планирования, выбираемого пользователем, и который будет определятся целочисленным типом данных. Горизонт планирования расчитывается в минутах и находится в диапазоне от 0 до 2,147,483,647 (ограничивается целочисленным типом данных языка C\#).

Для описания работ были выбраны следующие типы данных, доступные из библиотеки OR-Tools:
\begin{itemize}
	\item BoolVar
	\item IntVar
	\item OptionalIntervalVar
\end{itemize}

Тип данных IntVar в данной модели определяет переменные моментов начала и конца работ. Лежит в диапазоне от 0 до значения горизонта планирования.

Типом BoolVar определяется актуальность работы, то есть ее участие в процессе планирования. Данная переменная используется в типе OptionalIntervalVar. Переменная задается в диапазоне от 0 до 1 по умолчанию, соответственно если значение переменной равно единице, то работа учитывается при планировании, 0 - не учитывается.

OptionalIntervalVar уже определяет саму работу на горизонте планирования. В отличие от просто IntervalVar данный тип - опциональный и зависит от переменных типа BoolVar, используемых литералом is\_present.

Для составления модели до момента задания ограничений необходимо в первую очередь инициализировать работы, то есть инициализировать все переменные, представляющие работы.

В первоначальной версии модели инициализация была проделана так:
\begin{minted}{python}
for h in range(horizon)
    ...
    for w in workers
        ...
        for jt in job_types
            ...
            for job in jobs
\end{minted}

В данном варианте инициализация происходит относительно четырех сущностей модели: каждой минуты горизонта планирования, каждого рабочего, каждого типа работы и непосредственно каждой работы.

Отсюда, например, при 10 рабочих, 10 типах работ, 10 запланированных работах и горизонте планирования в 10080 минут (семь дней):

$10 * 10 * 10 * 10080 = 10080000$

Получаем некий объект, в котором уже для простейшего примера ресурсного планирования получем непомерно огромные затраты по памяти, причем полученную цифру в 10080000 необходимо еще умножить на 4, так как имеем при инициализации для каждой работы две переменных типа IntVar, одну BoolVar и одну OptionalIntervalVar, в итоге - свыше сорока миллионов объектов для простого тестового примера.

Необходимость в наличии инициализации относительно горизонта планирования была связана с недопониманием концепции использования опциональных интервалов. Изначально казалось необходимым наличие возможности начала работы в каждую из минут горизонта планирования, что соответственно добавляло лишнее измерение в инициализацию.

Тем не менее, такой подход оказался рабочим и выдавал удовлетворяющий результат, то есть соответствовал ограничениям и целевым функциям модели, откуда можем сделать вывод о возможности наличия более чем одного подхода в моделировании при решении проблем программирования в ограничениях.

Результаты исследований прототипа модели первой версии будут представлены ниже в соответствующей главе.

Во второй итерации модели, уже при переносе с языка Python на C\#, были найдены некоторые недочеты первой версии модели, а также пересмотрена процедура инициализации, в результате которой был убран цикл по горизонту планирования. Это обуславливается тем, что в интервальных переменных и так задается их момент возможного начала и момент возможного конца, соответственно нет необходимости в привязке начала интервалов к конкретному моменту горизонта планирования.

Итоговый вид инициализации на языке C\#:

\begin{minted}{csharp}
...
foreach (var w in workers)
{
    ...
    foreach (var jt in job_types)
    {
    ...
        foreach (var job in jobs)
        {
            if (jt == job.Type && w == job.WorkerID)
            {
                var performed_at = model.NewBoolVar($"performed by {w}wID {jt}type {job.ID}jID");
                var start = model.NewIntVar(0, horizon, $"start of {w} {jt} {job.ID}");
                var end = model.NewIntVar(0, horizon, $"end of {w} {jt} {job.ID}");
                var optint = model.NewOptionalIntervalVar(start, job.TimeSpanMinutes, end, performed_at, $"interval of {w} {jt} {job.ID}");
                ...
            }
        }
\end{minted}

Следующим шагом после инициализации входных данных для модели является задание ограничений.

Первая группа ограничений - работы одного типа, а так же работы одного рабочего не должны пересекаться.

Для этого языком подзапросов LINQ из переменных, представляющих входные данные необходимо достать необходимые работы. Для рабочих:
\begin{minted}{csharp}
//работы по рабочему
List<List<IntervalVar>> jobIntervals_by_worker = new();
foreach (var w in intervals_by_worker)
{
    var flatlist = w.SelectMany(i => i).ToList();
    jobIntervals_by_worker.Add(flatlist);
}

//работы одного рабочего не пересекаются
foreach (var ji in jobIntervals_by_worker)
{
    ji.AddRange(sleepIntervals);
    model.AddNoOverlap(ji);
}
\end{minted}

В данном примере следует обратить внимание на метод AddNoOverlap, который и устанавливает ограничение на непересечение элементов выборки ji, то есть множества работ одного рабочего.

Задание ограничений этой группы для работ одного типа происходит аналогично.

Дополнительно следует отметить, что для множества рабочих было задано дополнительное ограничение в виде работы только по будням с девяти утра до девяти вечера.

\begin{minted}{csharp}
//определим нерабочие (ночные интервалы) - допустим с 9 утра до 9 вечера
//даты планирования выбираются пользователем с 00:00 по 00:00
//0 + 540 => ночь; +720 => день; + 180 => остатки ночи
List<IntervalVar> sleepIntervals = new();
int dayCounter = 0;

foreach (DateTime day in EachDay(reftime, lastday))
{
    
    int st = dayCounter * 1440;
    
    if ((day.DayOfWeek == DayOfWeek.Saturday) || (day.DayOfWeek == DayOfWeek.Sunday))
    {
        //по выходным не работаем
        int fin1 = st + 1440;
        var siSS = model.NewIntervalVar(st, 1440, fin1, $"sat/sun {dayCounter}");
        sleepIntervals.Add(siSS);
    }
    else
    {
        //по будням - с 9 до 9
        int fin = st + 540;
        var si = model.NewIntervalVar(st, 540, fin, $"sleep 1 of day {dayCounter}");
        sleepIntervals.Add(si);
        st = fin + 720; //пропускаем рабочие 12 часов
        fin = st + 180;
        //второй ночной интервал
        var si2 = model.NewIntervalVar(st, 180, fin, $"sleep 2 of day {dayCounter}");
        sleepIntervals.Add(si2);
    }
    
    dayCounter++;
}
\end{minted}

\subsection{Экспериментальные исследования прототипа решения}

\clearpage
