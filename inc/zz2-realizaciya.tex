\section{Реализация предлагаемого решения и его оценка}

Реализация системы ресурсного планирования состоит в описании модели методами целочисленного программирования, интеграции этой модели в сервис планирования и написания подобия EAM-фронтенда, который будет взаимодействовать с сервисом, то есть отображать исходные данные, запускать процесс перепланирования, отображать результаты работы сервиса, а также различную статистику.

\subsection{Реализация прототипа технического решения}

\subsubsection{Описание инструментов и форматов данных}

В качестве среды программирования была выбрана Visual Studio 2022 под операционной системой Windows 11.

Библиотека Google Or-Tools поставляется из официального NuGet репозитория.

Как сервис ресурсного планирования, так и частичный функционал подобия ЕАМ-системы будут реализованы с помощью Blazor Server.

Данные о ресурсах и работах будут храниться в реляционной базе данных PostgreSQL, взаимодействие с базой данных извне будет происходить через SQL клиент DBeaver, а внутри проекта через ORM Entity Framework Core.

Структурная схема использованных инструментов представлена на рисунке \ref{instruments}.

\addimghere{instruments}{0.8}{Структура взаимосвязей инструментов.}{instruments}

\subsubsection{Описание прототипа программной реализации}
\subsubsection{Описание модели базы данных}

Схема реляционной базы данных, достаточной для описания модели, представленной в главе 1 представлена на рисунке \ref{schema}.

\addimghere{schema}{1}{Схема базы данных.}{schema}

В схеме представлены следующие сущности:
\begin{itemize}
	\item jobs
	\item jobtypes
	\item workers
	\item jobsworkers
\end{itemize}

Сущность jobs представляет все работы, запланированные на текущий момент времени.

Сущность jobtypes представляет все доступные типы работ. Связана с сущностью jobs связью один ко многим.

В таблице workers находятся все рабочие, которые могут быть привязаны к работам. Связана с таблицей jobs связью многие ко многим, поэтому необходимо использование промежуточной таблицы jobsworkers.

\subsubsection{Прототипирование ЕАМ-системы}

Для упрощения взаимодействия с сервисом планирования, а так же для упрощения написания вспомогательных инструментов, в качестве платформы для ЕАМ-системы был выбран веб-фреймворк Blazor Server.

При использовании модели хостинга Blazor Server приложение выполняется на сервере из приложения ASP.NET Core. Обновления пользовательского интерфейса, обработка событий и вызовы JavaScript обрабатываются через соединение SignalR.

Данный фреймворк позволяет создавать реактивные веб-приложения без использования языка JavaScript и его фреймворков, что значительно упрощает и ускоряет разработку веб-приложений для .Net программистов, не владеющих стеком технологий, таких как JavaScript, Angular, React и подобных.

Желаемый вид ЕАМ-системы представлен на рисунке \ref{interface}:

\addimghere{interface}{1}{Желаемый интерфейс прототипа ЕАМ-системы}{interface}

На рисунке показано основное окно системы - окно планирования работ, в котором находятся элементы управления для выбора плановых дат, перепланирования и записи результата в базу данных. Основным информационным элементом на данной странице является диаграмма Ганта.

Страница "Домой" служит для отображения основной информации о прототипе системы, страницы "Типы работ" и "Персонал" служат только для отображения исходных данных по сущностям "Типы работ" и "Персонал".

Диаграмма Ганта - столбчатая диаграмма, которая используется для иллюстрации плана или графика работ, например, во времени. Данный тип диаграмм повсеместно используется в системах подобного класса и очень удобен для отображения информации данного типа.

Так как диаграмма Ганта достаточно сложный к реализации элемент, было принято решение использовать его готовую реализацию. Готовая реализация была взята из пакета Syncfusion(ССЫЛКА), который бесплатно предоставляет ряд веб-компонент для некоммерческого использования и для студентов. Вид диаграммы из пакета Syncfusion Blazor представлен на рисунке \ref{syncgantt}.

\addimghere{syncgantt}{1}{Компонент диаграммы Ганта из пакета Syncfusion}{syncgantt}

Итоговый вид основного окна представлен на рисунке \ref{eammain}.

\addimghere{eammain}{1}{Страница планирования работ прототипа ЕАМ-системы}{eammain}

От кнопки сохранения перепланированных работ было решено отказаться, так как данный функционал является несущественным в рамках данной работы.

Остальные страницы прототипа представлены на рисунках \ref{homepage}, \ref{jobtypes} и \ref{staff}.

\addimghere{homepage}{1}{Домашняя страница прототипа}{homepage}

\addimghere{jobtypes}{1}{Страница "Типы работ"}{jobtypes}

\addimghere{staff}{1}{Страница "Персонал"}{staff}

Главным преимуществом использования фреймворка Blazor в подобных проектах является отсутствие необходимости в знании каких-либо дополнительных языков и их средств, например, JavaScript и React - вся реализация веб-приложения состоит целиком из HTML/CSS и кода на языке C\#.

В качестве примера можем рассмотреть страницу планирования работ. Данная страница состоит из двух частей: Razor страницы/компонента с расширением .razor или .cshtml и вспомогательного кода, наподобие модели-представления из паттерна MVVM. Вспомогательный код может находится либо прямо внутри представления, либо отдельным файлом как составной класс данного представления. Такая структура представлена на рисунке \ref{blazstruct}.

\addimghere{blazstruct}{1}{Страница "Персонал"}{blazstruct}

\subsubsection{Моделирование системы средствами программирования в ограничениях}

Все действия по планированию и/или перепланированию работ происходят на горизонте планирования, выбираемого пользователем, и который будет определятся целочисленным типом данных. Горизонт планирования расчитывается в минутах и находится в диапазоне от 0 до 2,147,483,647 (ограничивается целочисленным типом данных языка C\#).

Для описания работ были выбраны следующие типы данных, доступные из библиотеки OR-Tools:
\begin{itemize}
	\item BoolVar
	\item IntVar
	\item OptionalIntervalVar
\end{itemize}

Тип данных IntVar в данной модели определяет переменные моментов начала и конца работ. Лежит в диапазоне от 0 до значения горизонта планирования.

Типом BoolVar определяется актуальность работы, то есть ее участие в процессе планирования. Данная переменная используется в типе OptionalIntervalVar. Переменная задается в диапазоне от 0 до 1 по умолчанию, соответственно если значение переменной равно единице, то работа учитывается при планировании, 0 - не учитывается.

OptionalIntervalVar уже определяет саму работу на горизонте планирования. В отличие от просто IntervalVar данный тип - опциональный и зависит от переменных типа BoolVar, используемых литералом is\_present.

Для составления модели до момента задания ограничений необходимо в первую очередь инициализировать работы, то есть инициализировать все переменные, представляющие работы.

В первоначальной версии модели инициализация была проделана так:
\begin{minted}{python}
for h in range(horizon)
    ...
    for w in workers
        ...
        for jt in job_types
            ...
            for job in jobs
\end{minted}

В данном варианте инициализация происходит относительно четырех сущностей модели: каждой минуты горизонта планирования, каждого рабочего, каждого типа работы и непосредственно каждой работы.

Отсюда, например, при 10 рабочих, 10 типах работ, 10 запланированных работах и горизонте планирования в 10080 минут (семь дней):

$10 * 10 * 10 * 10080 = 10080000$

Получаем некий объект, в котором уже для простейшего примера ресурсного планирования получем непомерно огромные затраты по памяти, причем полученную цифру в 10080000 необходимо еще умножить на 4, так как имеем при инициализации для каждой работы две переменных типа IntVar, одну BoolVar и одну OptionalIntervalVar, в итоге - свыше сорока миллионов объектов для простого тестового примера.

Необходимость в наличии инициализации относительно горизонта планирования была связана с недопониманием концепции использования опциональных интервалов. Изначально казалось необходимым наличие возможности начала работы в каждую из минут горизонта планирования, что соответственно добавляло лишнее измерение в инициализацию.

Тем не менее, такой подход оказался рабочим и выдавал удовлетворяющий результат, то есть соответствовал ограничениям и целевым функциям модели, откуда можем сделать вывод о возможности наличия более чем одного подхода в моделировании при решении проблем программирования в ограничениях.

Результаты исследований прототипа модели первой версии будут представлены ниже в соответствующей главе.

Во второй итерации модели, уже при переносе с языка Python на C\#, были найдены некоторые недочеты первой версии модели, а также пересмотрена процедура инициализации, в результате которой был убран цикл по горизонту планирования. Это обуславливается тем, что в интервальных переменных и так задается их момент возможного начала и момент возможного конца, соответственно нет необходимости в привязке начала интервалов к конкретному моменту горизонта планирования.

Итоговый вид инициализации на языке C\#:

\begin{minted}{csharp}
...
foreach (var w in workers)
{
    ...
    foreach (var jt in job_types)
    {
    ...
        foreach (var job in jobs)
        {
            if (jt == job.Type && w == job.WorkerID)
            {
                var performed_at = model.NewBoolVar($"performed by {w}wID {jt}type {job.ID}jID");
                var start = model.NewIntVar(0, horizon, $"start of {w} {jt} {job.ID}");
                var end = model.NewIntVar(0, horizon, $"end of {w} {jt} {job.ID}");
                var optint = model.NewOptionalIntervalVar(start, job.TimeSpanMinutes, end, performed_at, $"interval of {w} {jt} {job.ID}");
                ...
            }
        }
\end{minted}

Следующим шагом после инициализации входных данных для модели является задание ограничений.

Первая группа ограничений - работы одного типа, а так же работы одного рабочего не должны пересекаться.

Для этого языком подзапросов LINQ из переменных, представляющих входные данные необходимо достать необходимые работы. Для рабочих:
\begin{minted}{csharp}
//работы по рабочему
List<List<IntervalVar>> jobIntervals_by_worker = new();
foreach (var w in intervals_by_worker)
{
    var flatlist = w.SelectMany(i => i).ToList();
    jobIntervals_by_worker.Add(flatlist);
}

//работы одного рабочего не пересекаются
foreach (var ji in jobIntervals_by_worker)
{
    ji.AddRange(sleepIntervals);
    model.AddNoOverlap(ji);
}
\end{minted}

В данном примере следует обратить внимание на метод AddNoOverlap, который и устанавливает ограничение на непересечение элементов выборки ji, то есть множества работ одного рабочего.

Задание ограничений этой группы для работ одного типа происходит аналогично.

Дополнительно следует отметить, что для множества рабочих было задано дополнительное ограничение в виде работы только по будням с девяти утра до девяти вечера.

\begin{minted}{csharp}
//определим нерабочие (ночные интервалы) - допустим с 9 утра до 9 вечера
//даты планирования выбираются пользователем с 00:00 по 00:00
//0 + 540 => ночь; +720 => день; + 180 => остатки ночи
List<IntervalVar> sleepIntervals = new();
int dayCounter = 0;

foreach (DateTime day in EachDay(reftime, lastday))
{   
    int st = dayCounter * 1440;
    if ((day.DayOfWeek == DayOfWeek.Saturday) || (day.DayOfWeek == DayOfWeek.Sunday))
    {
        //по выходным не работаем
        int fin1 = st + 1440;
        var siSS = model.NewIntervalVar(st, 1440, fin1, $"sat/sun {dayCounter}");
        sleepIntervals.Add(siSS);
    }
    else
    {
        //по будням - с 9 до 9
        int fin = st + 540;
        var si = model.NewIntervalVar(st, 540, fin, $"sleep 1 of day {dayCounter}");
        sleepIntervals.Add(si);
        st = fin + 720; //пропускаем рабочие 12 часов
        fin = st + 180;
        //второй ночной интервал
        var si2 = model.NewIntervalVar(st, 180, fin, $"sleep 2 of day {dayCounter}");
        sleepIntervals.Add(si2);
    }    
    dayCounter++;
}
\end{minted}

Следующим шагом необходимо ограничить возможное количество работ. В данном варианте мы считаем, что перепланированное количество работ одного типа и количество работ у одного рабочего должно быть меньше или равно исходному их количеству. Тогда для работ одного типа:

\begin{minted}{csharp}
///разделяем performed_at по типам работы
Console.WriteLine("разделяем performed_at по типам работы");
List<List<IntVar>> performedAt_by_type = new();
foreach (var t in job_types)
{
    List<IntVar> perflist = new();
    performedAt_by_type.Add(perflist);
}
foreach (var b_worker in bools_by_worker)
{
    for (int b_type = 0; b_type < b_worker.Count; b_type++)
    {
        var flatperf = b_worker[b_type];
        performedAt_by_type[b_type].AddRange(flatperf);
    }
}
for (int i = 0; i < performedAt_by_type.Count; i++)
{
    model.Add(LinearExpr.Sum(performedAt_by_type[i]) <= job_type_num[i]);
}
\end{minted}

Необходимое ограничение задается в строке \mintinline{csharp}|model.Add(LinearExpr.Sum(performedAt_by_type[i]) <= job_type_num[i])|, где метод Add() задает для модели некое линейное ограничение. Метод LinearExpr.Sum(), переданный в Add() позволяет производить над множествами объектов типа OR-Tools операцию сложения значений элементов множества. Соответственно данной строкой мы задаем для модели, что количество работ перепланированных меньше или равно количеству работ исходных.

Ограничение по количеству работ для конкретных рабочих задается аналогично.

Так как у работ может быть задана некая периодичность выполнения, например, каждый день, раз в неделю, раз в месяц и так далее, то необходимо задать механизм эту периодичность устанавливающий.

Изначально данное ограничение представлялось очень простым. У каждой работы (опционального интервала) заданы переменные start и end типа IntVar, обозначающие возможный момент начала и возможный момент окончание работы. Соотвественно ограничение выглядело тривиально: $start_{n+1} - end_n > X$, где $X$ - интервал, через который плановые работы одного типа должны выполняться.

Так как переменные start и end используются в опциональном интервале, то ожидалось, что при невозможности для двух работ соответствовать ограничению $start_{n+1} - end_n > X$ - данные работы просто не будут учитываться, так как привязаны к типу OptionalIntervalVar. В действительности же заданные ограничения при невозможности их удовлетворить делали всю модель невыполнимой, в связи с тем, что ограничения к данным переменным рассматриваются сами по себе и без привязки к другим типам в модели. Именно для таких случаев используются связывающие ограничения.

Связывающие ограничения (от англ. - channeling constraint) связывают переменные внутри модели. Они используются, когда необходимо выразить сложную связь между переменными, например, "если эта переменная удовлетворяет условию, то она заставляет другую переменную принять определенное значение".

В данном случае необходимо указать, что если ограничение $start_{n+1} - end_n > X$ выполнимо, то литерал is\_present, отвечающий за актуальность опционального интервала, станет равным единице, то есть работа с этим литералом будет учитываться при планировании.

Выражается таким образом:

\begin{minted}{csharp}
//для третьего типа (плановая работа) - работы не чаще раза в день
    ...
    if(type == 3)
    {
        for (int i = 0; i < startAt_by_type[k].Count - 1; i++)
        {
            for (int j = i+1; j < startAt_by_type[k].Count; j++)
            {
                //if (b-a>1440) => b=0
                model.Add(startAt_by_type[k][j] - endAt_by_type[k][i] >= 1440).OnlyEnforceIf(performedAt_by_type[k][i]);
            }
        }
        break;
    }
    ...    
\end{minted}

В этом примере с помощью метода OnlyEnforceIf() устанавливается, что если выполнятся ограничение в методе Add(), то переменная типа BoolVar внутри метода OnlyEnforceIf() обратится в 1.

Последним шагом остается задать целевую функцию. В качестве целевой функции предлагается максимизировать количество перепланированных работ в целом. Для этого напишем такой код:

\begin{minted}{csharp}
//возьмем множество всех работ
var flatbools = bools_by_worker.SelectMany(i => i).SelectMany(i => i);
//целевая функция - максимизировать количество работ
model.Maximize(LinearExpr.Sum(flatbools));
\end{minted}

В данном примере целевая функция задается через метод модели Maximize(), в который передается множество всех работ. В данном случае каждый объект элемент множества является типом данных BoolVar.


\subsection{Экспериментальные исследования прототипа решения}

\clearpage
