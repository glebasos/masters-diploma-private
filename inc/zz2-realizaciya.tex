\section{Реализация предлагаемого решения и его оценка}

Реализация системы ресурсного планирования состоит в описании модели методами целочисленного программирования, интеграции этой модели в сервис планирования и написания подобия EAM-фронтенда, который будет взаимодействовать с сервисом, то есть отображать исходные данные, запускать процесс перепланирования, отображать результаты работы сервиса, а также различную статистику.

\subsection{Реализация прототипа технического решения}

\subsubsection{Описание инструментов и форматов данных}

В качестве среды программирования была выбрана Visual Studio 2022 под операционной системой Windows 11.

Библиотека Google Or-Tools поставляется из официального NuGet репозитория.

Как сервис ресурсного планирования, так и частичный функционал подобия ЕАМ-системы будут реализованы с помощью Blazor Server.

Данные о ресурсах и работах будут храниться в реляционной базе данных PostgreSQL, взаимодействие с базой данных извне будет происходить через SQL клиент DBeaver, а внутри проекта через ORM Entity Framework Core.

Структурная схема использованных инструментов представлена на рисунке \ref{instruments}.

\addimghere{instruments}{0.8}{Структура взаимосвязей инструментов.}{instruments}

\subsubsection{Описание модели базы данных}

Схема реляционной базы данных, достаточной для описания модели, представленной в главе 1 представлена на рисунке \ref{schema}.

\addimghere{schema}{1}{Схема базы данных.}{schema}

В схеме представлены следующие сущности:
\begin{itemize}
	\item jobs
	\item jobtypes
	\item workers
	\item jobsworkers
\end{itemize}

Сущность jobs представляет все работы, запланированные на текущий момент времени.

Сущность jobtypes представляет все доступные типы работ. Связана с сущностью jobs связью один ко многим.

В таблице workers находятся все рабочие, которые могут быть привязаны к работам. Связана с таблицей jobs связью многие ко многим, поэтому необходимо использование промежуточной таблицы jobsworkers.

\subsubsection{Прототипирование ЕАМ-системы}

Для упрощения взаимодействия с сервисом планирования, а так же для упрощения написания вспомогательных инструментов, в качестве платформы для ЕАМ-системы был выбран веб-фреймворк Blazor Server.

При использовании модели хостинга Blazor Server приложение выполняется на сервере из приложения ASP.NET Core. Обновления пользовательского интерфейса, обработка событий и вызовы JavaScript обрабатываются через соединение SignalR.

Данный фреймворк позволяет создавать реактивные веб-приложения без использования языка JavaScript и его фреймворков, что значительно упрощает и ускоряет разработку веб-приложений для .Net программистов, не владеющих стеком технологий, таких как JavaScript, Angular, React и подобных.

Желаемый вид ЕАМ-системы представлен на рисунке \ref{interface}:

\addimghere{interface}{1}{Желаемый интерфейс прототипа ЕАМ-системы}{interface}

На рисунке показано основное окно системы - окно планирования работ, в котором находятся элементы управления для выбора плановых дат, перепланирования и записи результата в базу данных. Основным информационным элементом на данной странице является диаграмма Ганта.

Страница "Домой" служит для отображения основной информации о прототипе системы, страницы "Типы работ" и "Персонал" служат только для отображения исходных данных по сущностям "Типы работ" и "Персонал".

Диаграмма Ганта - столбчатая диаграмма, которая используется для иллюстрации плана или графика работ, например, во времени. Данный тип диаграмм повсеместно используется в системах подобного класса и очень удобен для отображения информации данного типа.

Так как диаграмма Ганта достаточно сложный к реализации элемент, было принято решение использовать его готовую реализацию. Готовая реализация была взята из пакета Syncfusion \cite{syncblazor}, который бесплатно предоставляет ряд веб-компонент для некоммерческого использования и для студентов. Вид диаграммы из пакета Syncfusion Blazor представлен на рисунке \ref{syncgantt}.

\addimghere{syncgantt}{1}{Компонент диаграммы Ганта из пакета Syncfusion}{syncgantt}

Пакет готовых форм Syncfusion предоставляет возможность отображения работ одного типа в одной строке только в версии для фреймворка Angular, поэтому в данном прототипе каждая работа представлена отдельной строчкой на диаграмме.

Итоговый вид основного окна представлен на рисунке \ref{eammain}.

\addimghere{eammain}{1}{Страница планирования работ прототипа ЕАМ-системы}{eammain}

От кнопки сохранения перепланированных работ было решено отказаться, так как данный функционал не является необходимым для выполнения данной работы.

Остальные страницы прототипа представлены на рисунках \ref{homepage}, \ref{jobtypes} и \ref{staff}.

\addimghere{homepage}{1}{Домашняя страница прототипа}{homepage}

\addimghere{jobtypes}{1}{Страница "Типы работ"}{jobtypes}

\addimghere{staff}{1}{Страница "Персонал"}{staff}

Главным преимуществом использования фреймворка Blazor в подобных проектах является отсутствие необходимости в знании каких-либо дополнительных языков и их средств, например, JavaScript и React - вся реализация веб-приложения состоит целиком из HTML/CSS и кода на языке C\#.

В качестве примера можем рассмотреть страницу планирования работ. Данная страница состоит из двух частей: Razor страницы/компонента с расширением .razor или .cshtml и вспомогательного кода, наподобие модели-представления из паттерна MVVM. Вспомогательный код может находится либо прямо внутри представления, либо отдельным файлом как составной класс данного представления. Такая структура представлена на рисунке \ref{blazstruct}.

\addimghere{blazstruct}{1}{Структура razor-страниц}{blazstruct}

Как видно из рисунка выше, в представлении Gantt.razor задан HTML-код со вставками на C\#. Данные вставки берутся из методов и свойств составного класса Gantt.razor.cs и позволяют реактивно менять значения на странице.

\subsubsection{Моделирование системы средствами программирования в ограничениях}

Все действия по планированию и/или перепланированию работ происходят на горизонте планирования, который выбирается пользователем и в рамках данной работы определятся целочисленным типом данных. Горизонт планирования рассчитывается в минутах и находится в диапазоне от 0 до 2,147,483,647 (ограничивается целочисленным типом данных языка C\#). Такой диапазон покрывает 4085 лет и является более, чем достаточным для всех реальных задач планирования в EAM-системах. Был выбран горизонт планирования в минутах, так как он обеспечивает достаточную точность относительно часов, а в численном виде значительно меньше секунд, что сократит необходимую память для планирования.

Для описания работ были выбраны следующие типы данных, доступные из библиотеки OR-Tools:
\begin{itemize}
	\item BoolVar
	\item IntVar
	\item OptionalIntervalVar
\end{itemize}

Тип данных IntVar в данной модели определяет переменные моментов начала и конца работ. Лежит в диапазоне от 0 до значения горизонта планирования.

Типом BoolVar определяется актуальность работы, то есть ее участие в процессе планирования. Данная переменная используется в типе OptionalIntervalVar. Переменная задается в диапазоне от 0 до 1 по умолчанию, соответственно если значение переменной равно единице, то работа учитывается при планировании, 0 - не учитывается.

OptionalIntervalVar уже определяет саму работу на горизонте планирования. В отличие от просто IntervalVar данный тип - опциональный и зависит от переменных типа BoolVar, используемых литералом is\_present.

Для составления модели до момента задания ограничений необходимо в первую очередь инициализировать работы, то есть инициализировать все переменные, представляющие работы.

В первоначальной версии модели инициализация была проделана так:
\begin{minted}{python}
for h in range(horizon)
    ...
    for w in workers
        ...
        for jt in job_types
            ...
            for job in jobs
\end{minted}

В данном варианте инициализация происходит относительно четырех сущностей модели: каждой минуты горизонта планирования, каждого рабочего, каждого типа работы и непосредственно каждой работы.

Отсюда, например, при 10 рабочих, 10 типах работ, 10 запланированных работах и горизонте планирования в 10080 минут (семь дней):

$10 * 10 * 10 * 10080 = 10080000$

Получаем некий объект, в котором уже для простейшего примера ресурсного планирования получим непомерно огромные затраты по памяти, причем полученную цифру в 10080000 необходимо еще умножить на 4, так как имеем при инициализации для каждой работы две переменных типа IntVar, одну BoolVar и одну OptionalIntervalVar, в итоге - свыше сорока миллионов объектов для простого тестового примера.

Необходимость в наличии инициализации относительно горизонта планирования была связана с недопониманием концепции использования опциональных интервалов. Изначально казалось необходимым наличие возможности начала работы в каждую из минут горизонта планирования, что соответственно добавляло лишнее измерение в инициализацию.

Тем не менее, такой подход оказался рабочим и выдавал удовлетворяющий результат, то есть соответствовал ограничениям и целевым функциям модели, откуда можем сделать вывод о возможности наличия более чем одного подхода в моделировании при решении проблем программирования в ограничениях.

Результаты исследований прототипа модели первой версии будут представлены ниже в соответствующей главе.

Во второй итерации модели, уже при переносе с языка Python на C\#, были найдены некоторые недочеты первой версии модели, а также пересмотрена процедура инициализации, в результате которой был убран цикл по горизонту планирования. Это обуславливается тем, что в интервальных переменных и так задается их момент возможного начала и момент возможного конца, соответственно нет необходимости в привязке начала интервалов к конкретному моменту горизонта планирования.

Итоговый вид инициализации на языке C\#:

\begin{minted}{csharp}
...
foreach (var w in workers)
{
    ...
    foreach (var jt in job_types)
    {
    ...
        foreach (var job in jobs)
        {
            if (jt == job.Type && w == job.WorkerID)
            {
                var performed_at = model.NewBoolVar($"performed by {w}wID {jt}type {job.ID}jID");
                var start = model.NewIntVar(0, horizon, $"start of {w} {jt} {job.ID}");
                var end = model.NewIntVar(0, horizon, $"end of {w} {jt} {job.ID}");
                var optint = model.NewOptionalIntervalVar(start, job.TimeSpanMinutes, end, performed_at, $"interval of {w} {jt} {job.ID}");
                ...
            }
        }
\end{minted}

Следующим шагом после инициализации входных данных для модели является задание ограничений.

Первая группа ограничений - работы одного типа, а так же работы одного рабочего не должны пересекаться.

Для этого языком подзапросов LINQ из переменных, представляющих входные данные необходимо достать необходимые работы. Для рабочих:
\begin{minted}{csharp}
//работы по рабочему
List<List<IntervalVar>> jobIntervals_by_worker = new();
foreach (var w in intervals_by_worker)
{
    var flatlist = w.SelectMany(i => i).ToList();
    jobIntervals_by_worker.Add(flatlist);
}

//работы одного рабочего не пересекаются
foreach (var ji in jobIntervals_by_worker)
{
    ji.AddRange(sleepIntervals);
    model.AddNoOverlap(ji);
}
\end{minted}

В данном примере следует обратить внимание на метод AddNoOverlap, который и устанавливает ограничение на непересечение элементов выборки ji, то есть множества работ одного рабочего.

Задание ограничений этой группы для работ одного типа происходит аналогично.

Дополнительно следует отметить, что для множества рабочих было задано дополнительное ограничение в виде работы только по будням с девяти утра до девяти вечера.

\begin{minted}{csharp}
    //определим нерабочие (ночные интервалы) - допустим с 9 утра до 9 вечера
    //даты планирования выбираются пользователем с 00:00 по 00:00
    //0 + 540 => ночь; +720 => день; + 180 => остатки ночи
    List<IntervalVar> sleepIntervals = new();
    int dayCounter = 0;
    
    foreach (DateTime day in EachDay(reftime, lastday))
    {   
        int st = dayCounter * 1440;
        if ((day.DayOfWeek == DayOfWeek.Saturday) || (day.DayOfWeek == DayOfWeek.Sunday))
        {
            //по выходным не работаем
            int fin1 = st + 1440;
            var siSS = model.NewIntervalVar(st, 1440, fin1, $"sat/sun {dayCounter}");
            sleepIntervals.Add(siSS);
        }
        else
        {
            //по будням - с 9 до 9
            int fin = st + 540;
            var si = model.NewIntervalVar(st, 540, fin, $"sleep 1 of day {dayCounter}");
            sleepIntervals.Add(si);
            st = fin + 720; //пропускаем рабочие 12 часов
            fin = st + 180;
            //второй ночной интервал
            var si2 = model.NewIntervalVar(st, 180, fin, $"sleep 2 of day {dayCounter}");
            sleepIntervals.Add(si2);
        }    
        dayCounter++;
    }
\end{minted}

Следующим шагом необходимо ограничить возможное количество работ. В данном варианте мы считаем, что перепланированное количество работ одного типа и количество работ у одного рабочего должно быть меньше или равно исходному их количеству. Тогда для работ одного типа:

\begin{minted}{csharp}
    ///разделяем performed_at по типам работы
    Console.WriteLine("разделяем performed_at по типам работы");
    List<List<IntVar>> performedAt_by_type = new();
    foreach (var t in job_types)
    {
        List<IntVar> perflist = new();
        performedAt_by_type.Add(perflist);
    }
    foreach (var b_worker in bools_by_worker)
    {
        for (int b_type = 0; b_type < b_worker.Count; b_type++)
        {
            var flatperf = b_worker[b_type];
            performedAt_by_type[b_type].AddRange(flatperf);
        }
    }
    for (int i = 0; i < performedAt_by_type.Count; i++)
    {
        model.Add(LinearExpr.Sum(performedAt_by_type[i]) <= job_type_num[i]);
    }
\end{minted}

Необходимое ограничение задается в строке \mintinline{csharp}|model.Add(LinearExpr.Sum(performedAt_by_type[i]) <= job_type_num[i])|, где метод Add() задает для модели некое линейное ограничение. Метод LinearExpr.Sum(), переданный в Add() позволяет производить над множествами объектов типа OR-Tools операцию сложения значений элементов множества. Соответственно данной строкой мы задаем для модели, что количество работ перепланированных меньше или равно количеству работ исходных.

Ограничение по количеству работ для конкретных рабочих задается аналогично.

Так как у работ может быть задана некая периодичность выполнения, например, каждый день, раз в неделю, раз в месяц и так далее, то необходимо задать механизм эту периодичность устанавливающий.

Изначально данное ограничение представлялось очень простым. У каждой работы (опционального интервала) заданы переменные start и end типа IntVar, обозначающие возможный момент начала и возможный момент окончания работы. Соотвественно ограничение выглядело тривиально: $start_{n+1} - end_n > X$, где $X$ - интервал, через который плановые работы одного типа должны выполняться.

Так как переменные start и end используются в опциональном интервале, то ожидалось, что при невозможности для двух работ соответствовать ограничению $start_{n+1} - end_n > X$ - данные работы просто не будут учитываться, так как привязаны к типу OptionalIntervalVar. В действительности же заданные ограничения при невозможности их удовлетворить делали всю модель невыполнимой, в связи с тем, что ограничения к данным переменным рассматриваются сами по себе и без привязки к другим типам в модели. Именно для таких случаев используются связывающие ограничения.

Связывающие ограничения (от англ. - channeling constraint) связывают переменные внутри модели. Они используются, когда необходимо выразить сложную связь между переменными, например, "если эта переменная удовлетворяет условию, то она заставляет другую переменную принять определенное значение".

В данном случае необходимо указать, что если ограничение $start_{n+1} - end_n > X$ выполнимо, то литерал is\_present, отвечающий за актуальность опционального интервала, станет равным единице, то есть работа с этим литералом будет учитываться при планировании.

Выражается таким образом:

\begin{minted}{csharp}
//для третьего типа (плановая работа) - работы не чаще раза в день
    ...
    if(type == 3)
    {
        for (int i = 0; i < startAt_by_type[k].Count - 1; i++)
        {
            for (int j = i+1; j < startAt_by_type[k].Count; j++)
            {
                //if (b-a>1440) => b=0
                model.Add(startAt_by_type[k][j] - endAt_by_type[k][i] >= 1440).OnlyEnforceIf(performedAt_by_type[k][i]);
            }
        }
        break;
    }
    ...    
\end{minted}

В этом примере с помощью метода OnlyEnforceIf() устанавливается, что если выполнятся ограничение в методе Add(), то переменная типа BoolVar внутри метода OnlyEnforceIf() обратится в 1.

Последним шагом остается задать целевую функцию. В качестве целевой функции предлагается максимизировать количество перепланированных работ в целом. Для этого напишем такой код:

\begin{minted}{csharp}
//возьмем множество всех работ
var flatbools = bools_by_worker.SelectMany(i => i).SelectMany(i => i);
//целевая функция - максимизировать количество работ
model.Maximize(LinearExpr.Sum(flatbools));
\end{minted}

В данном примере целевая функция задается через метод модели Maximize(), в который передается множество всех работ. В данном случае каждый объект элемент множества является типом данных BoolVar.


\subsection{Экспериментальные исследования прототипа решения}

После создания прототипа была проведена экспериментальная оценка пригодности системы для задач ресурсного планирования в соответствии с поставленной задачей.

Основные характеристики аппаратно-программной конфигурации, которая использовалась для создания прототипа: компьютер – AMD Ryzen 9 5900HX, видеокарта Nvidia GeForce RTX 3070 Laptop 8Гб, оперативная память 16Гб DDR4.

Основными критериями для исследований предлагается использовать:
\begin{itemize}
    \item Зависимость времени планирования от количества работ/ресурсов
    \item Зависимость требуемой памяти от количества работ/ресурсов
    \item Результативность алгоритма (процент количества перепланированных работ от исходного)
\end{itemize}

\subsubsection{Сравнение двух версий модели}

Для начала рассмотрим время планирования (рисунок \ref{1vs2time}) и требуемый объем памяти (рисунок \ref{1vs2ram}) для планирования 13 работ на горизонте в одну неделю для моделей первой и второй версии:

\addimghere{1vs2time}{0.8}{Разница во времени планирования для моделей первой и второй версии (меньше - лучше)}{1vs2time}

\addimghere{1vs2ram}{0.8}{Разница в требуемой оперативной памяти для моделей первой и второй версии (меньше - лучше)}{1vs2ram}

По графикам, представленным на рисунках \ref{1vs2time} и \ref{1vs2ram}, видно, что модель второй версии отрабатывает на порядок быстрее и требует на порядок меньше памяти. Время перепланирования первой модели составило 14 минут, второй модели - 5 секунд, для работы первой модели потребовалось 12 гигабайт оперативной памяти, а для работы второй - всего лишь 300 мегабайт.

Такая явная разница в результатах работы обусловлена, как было указано выше в части 3.1.4, наличием лишнего измерения при инициализации данных вследствие применения ошибочного подхода при моделировании.

Представленные выше графики показывают, что хотя результаты работы разных вариантов модели для одной и той же задачи могут быть удовлетворительными, далеко не все из них могут быть применимы в реальных условиях, так как по тем или иным причинам могут не соответствовать требованиям по памяти или быстродействию.

\subsubsection{Анализ работы итоговой версии модели}

Рассмотрим результаты работы второй (итоговой) версии модели.

В первую очередь проверим перепланирование в граничных условиях, для которых заранее известен результат планирования в соответствии с постановкой задачи.

Так как при моделировании были использованы нестрогие ограничения, мы точно можем сказать, что количество запланированных работ будет больше нуля при любых начальных условиях. Единственным вариантом, в котором представляется отсутствие перепланированных работ является вариант, где выбранный горизонт планирования меньше времени наименьшей работы. Такой вариант является нереалистичным и рассматриваться не будет.

Для тестирования работы в граничных условиях приведём вариант планирования работ нескольких типов на горизонте одного дня, где все работы назначены одному человеку и не могут выполниться в полном объёме не пересекаясь (рис. \ref{borderinit}).

\addimghere{borderinit}{0.9}{Заведомо неисполнимый вариант планирования потребности в работах}{borderinit}

По рисунку выше видно, что есть пять работ типов "Обход", "Ремонт", "Плановый осмотр", "Замена", которые явно следуют друг за другом и не пересекаются. Работы типа "Остановка" находятся в границах других работ и выполнены быть не могут.

Очевидно, что исходя из данной диаграммы Ганта как минимум пять работ должны остаться после перепланирования. Есть вероятность, что при данных начальных условиях работы можно перепланировать так, что их возможное непересекающееся множество будет состоять более чем из пяти интервалов, но уже даже на такой небольшой выборке видно, что для человека задача становится достаточно нетривиальной и потребует относительно долгое время на разрешение.

Результат перепланирвоания представлен на рисунке \ref{borderafter}. 

\addimghere{borderafter}{0.9}{Результат работы планировщика в граничных условиях}{borderafter}

Как видно из рисунка \ref{borderafter}, планировщик исключил самую длинную работу по замене, оставив вместо нее две работы по остановке, длинна которых эквивалентна работе по замене, тем самым увеличив количество запланированных работ. Непосредственно процедура перепланирования заняла меньше 1 секунды и потребовала 250 мегабайт оперативной памяти.

В интерфейсе прототипа ЕАМ-системы результат перепланирования (рис. \ref{bordeream}) выглядит так:
    
\addimghere{bordeream}{0.8}{Результат работы планировщика в граничных условиях в интерфейсе ЕАМ-системы}{bordeream}

В качестве второго граничного условия определим 100 случайно заданных работ на горизонте планирования в одни сутки.

По результатам тестирования в данных условиях перепланировать удалось лишь 51 из 100 работ. Визуальный осмотр результатов, сравнение диаграмм Ганта до и после, просмотр логов планировщика не выявили аномальных или подозрительных результатов, а перепланированные интервалы соответствовали поставленной задаче, поэтому можно сделать вывод, что в данном граничном эксперименте модель также отработала корректно.

При таких входных данных наиболее интересным для исследования оказался параметр времени перепланирования при разном количестве задействованных на алгоритм ядер процессора.

На рисунке \ref{procusage} показана зависимость времени планирования от количества используемых процессоров.

\addimghere{procusage}{0.9}{Зависимость времени планирования от количества задействованных ядер процессора}{procusage}

По результатам эксперимента выше видим, что количество задействованных процессоров является одним из самых важных факторов быстродействия в данной модели. При использовании множества процессоров, каждый из них выполняет свою часть по поиску решений из множества всех решений.

Анализируя результат эксперимента в граничных условиях можно сказать, что планировщик корректно отработал в рамках поставленной задачи, показав высокую скорость работы и относительно небольшие требования к оперативной памяти. При этом, ключевую роль в быстродействии алгоритма перепланирования сыграло количество задействованных процессоров, показавшее явный, фактически линейный тренд на уменьшение времени планирования при увеличении количества процессоров.

Рассмотрим зависимость метрик перепланирования от количества работ и горизонта планирования. Количество типов работ и рабочих для всех тестов будет оставаться неизменным и равным десяти. Типы работ, продолжительность и дата выбираются случайным образом.

На рисунках \ref{100jtime} и \ref{1000jtime} показано время в секундах, требуемое для перепланирования 100 и 1000 работ на горизонте от 31 до 365 дней.

\addimghere{100jtime}{0.9}{Зависимость времени планирования от количества задействованных ядер процессора}{100jtime}

\addimghere{1000jtime}{0.9}{Зависимость времени планирования от количества задействованных ядер процессора}{1000jtime}

По представленным графикам видно, что на требуемое время планирование всех работ сильно влияет выбранный горизонт планирования. Данная зависимость связана с тем, что на длительных интервалах горизонта планирования существует достаточно свободного места для всех работ, и планирование в таком случае становится достаточно тривиальным.

Соответственно, чем меньше задается выбранный интервал, тем меньше становится вариантов расположить необходимое количество работ, то есть сужается множество удовлетворяющих решений на всем возможном множестве решений.

По графику \ref{1000jtime} сильно заметно влияние использования нескольких процессорных ядер для процесса планирования. Перепланирование с 8 ядрами оказалось примерно в 8 раз быстрее одноядерного перепланирования, что также соотносится с результатами, полученными в тестировании граничных условий (рис. \ref{procusage}).

Проведем замеры скорости планирования в зависимости от количества работ на горизонте в один год. Так как работы выбираются и распределяются в случайном порядке, проведем эксперимент 10 раз и построим зависимость от среднего времени перепланирования.

График зависимости времени планирования от количества работ представлен на рисунке \ref{365d2k}:

\addimghere{365d2k}{0.9}{Зависимость времени планирования от количества работ}{365d2k}

Как видно из рисунка \ref{365d2k}, примерное количество работ, которое в кратчайшие сроки может быть запланировано на один год находится в промежутке от 0 до 1900 работ. В процессе тестирования был выявлен промежуток, в котором перепланирование начинало занимать больше часа времени - данный промежуток составил от 1900 до 2100 работ. Среднее время перепланирования в интервале до 1900 работ составило менее 10 секунд. Увеличение горизонта планирования до двух лет позволило завершить операцию перепланирования за 3 секунды.

Было проведено исследование зависимости времени перепланирования от количества доступных рабочих. При уменьшении их количества в два раза, количество работ, которые возможно перепланировать в короткие сроки так же уменьшилось в два раза, и находится в промежутке от 800 до 1100 работ. Увеличение же числа рабочих в два раза не повлияло на время перепланирования, исходя из чего можем сделать вывод о наличии некой границы, ограничивающей быстроту перепланирования для данной модели.

Одной из интересных метрик оказалась средняя плотность запланированных работ в день (рис. \ref{plotn10}), при которой модель справляется с перепланированием пределах двух-трех часов:

\addimghere{plotn10}{0.9}{График зависимости средней плотности планирования работ от горизонта планирования}{plotn10}

По графику, представленному на рисунке \ref{plotn10} видно, что для 10 типов работ средняя максимальная плотность перепланирования составила около 5.5 работ в день при горизонте планирования от 180 дней и более. Под максимальной плотностью в данном случае понимается такая плотность, которая достигается при количестве работ, перепланируемых не более чем за три часа. Высокая плотность в пределах 180 дней связана с тем, что за аналогичное время модель способна разместить большее количество работ при меньшем горизонте планирования.

Проверим зависимость времени перепланирования при 20 типах работ (рис. \ref{20jtsmall} и рис. \ref{20jtbig}):

\addimghere{20jtsmall}{0.9}{Зависимость времени планирования от количества работ при 20 типах работ}{20jtsmall}

\addimghere{20jtbig}{0.9}{Зависимость времени планирования от количества работ при 20 типах работ до момента подскока времени планирования}{20jtbig}

Проверим, сохранится ли вид графика плотности планирования при большем количестве типов работ. Исходя из результатов, полученных в экспериментах выше, график должен сохранить свою форму, а средняя плотность должна быть примерно в два раза больше.

График плотности от 20 типов работ представлен на рисунке \ref{plotn20}:

\addimghere{plotn20}{0.9}{График зависимости средней плотности планирования работ от горизонта планирования}{plotn20}

Как видно из рисунка \ref{plotn20}, форма графика соответствует форме графика плотности от 10 типов работ, а средняя плотность при долгосрочном планировании увеличилась в 2.4 раза, что так же соответствует ожиданиям.

Последней метрикой для рассмотрения выберем зависимость количества перепланированных работ от количества доступных рабочих. Аналогичный эксперимент с типами работ показал явную зависимость от изменения количества типов, поведение модель в данном эксперименте ожидается похожим.

На рисунке \ref{work20} представлены графики зависимости количества работ от горизонта планирования при разном количестве доступных рабочих:

\addimghere{work20}{0.9}{График зависимости средней плотности планирования работ от горизонта планирования}{work20}

Подобно закону Густафсона-Амдала, в данном случае больший интерес вызывает не быстродействие при определенном объеме вычислений, а объем вычислений при сходном времени. Как видим из рисунка \ref{work20}, в отличие от изменения количества типов работ, изменение количества доступных рабочих не так сильно повлияло на объем модели при сходном времени. Такое поведение модели можно объяснить тем, что на типы работ накладывается больше ограничений, нежели чем на рабочих, соответственно при ослаблении начальных условий (например, увеличении горизонта планирования или увеличения числа типов работ) становится возможным распределить большее количество работ. Так же необходимо учесть, что рабочие в иерархии инициализации находятся под типами работ, соответственно пласт решений связанных с рабочими частично отсекается сам по себе при нахождении решений для типов работ.

\subsubsection{Выводы по итогам эксперимента}
По итогам эксперимента было выявлено, что разработанная модель работает в соответствии с поставленной задачей.

Модель корректно отработала в граничных условиях, показав ожидаемы и соответствующие поставленной задаче результаты.

Ключевым параметром системы при работе сервиса планирования оказалось количество ядер процессора, способных параллельно решать задачу перепланирования, так как каждое из ядер берет на себя часть работы по поиску удовлетворяющих решений из всего множества.

Горизонт планирования сильно влияет как на время планирования, так и на количество работ, так как является одним из главных ограничителей для возможного количества распределенных работ.

Количество типов работ значительно влияет на скорость перепланирования и на объем возможных работ за определенное время, так как для типов работ задано больше всего ограничений.

Количество же рабочих меньше всего влияет на процесс перепланирования, так как для них задается меньше ограничений, а часть из множества решений связанных с рабочими отсекается при отсечении решений для типов работ.

Избежать излишнего времени, которое может быть затрачено на перепланирование не удалось, но длительное время планирования является стандартной практикой в области операционных исследований, поэтому лишь частично является минусом в данной ситуации, так как относительно большой объем данных так же возможно перепланировать и в короткие сроки, то  есть в пределах нескольких минут.

В целом прототип системы можно назвать пригодным для использования, так как он справляется с представленной задачей.

В дальнейшем планируется наращивание прототипа, а именно:

\begin{itemize}
    \item Оптимизация инициализации модели и накладываемых ограничений.
    \item Возможность привязки дополнительных типов сущностей к работам.
    \item Возможность использования одновременно нескольких сущностей одного типа.
    \item Доработка схемы базы данных в соответствии с изменениями модели.
    \item Добавление поддержки составных работ.
\end{itemize}
\clearpage
